# Database Migrations with Alembic

## Overview

Alembic is SQLAlchemy's database migration tool that enables version control for database schemas. It's essential for maintaining database consistency across development, testing, and production environments in the Order Management System.

## Why Alembic Matters

### üèóÔ∏è **Database Evolution**
- **Version Control**: Track database schema changes over time
- **Migration Scripts**: Auto-generate SQL migration files from model changes
- **Environment Management**: Separate configurations for dev/staging/production
- **Rollback Support**: Safely revert problematic changes

### üöÄ **Production Benefits**
- **Zero-downtime deployments**: Migrate database without stopping service
- **Schema evolution**: Add/modify tables, columns, indexes safely
- **Data integrity**: Preserve existing data during structural changes
- **Team collaboration**: Shared database schema evolution

## Installation & Setup

Alembic is included in your project dependencies via `pyproject.toml`:

```toml
[project]
dependencies = [
    "alembic>=1.13.0",
    "sqlalchemy>=2.0.0",
    # ... other dependencies
]

Initialize Alembic (already done in this project)

# This creates alembic/ directory and alembic.ini
alembic init alembic

order-system/
‚îú‚îÄ‚îÄ alembic/
‚îÇ   ‚îú‚îÄ‚îÄ env.py              # Migration environment
‚îÇ   ‚îú‚îÄ‚îÄ script.py.mako      # Migration template
‚îÇ   ‚îî‚îÄ‚îÄ versions/           # Migration files
‚îú‚îÄ‚îÄ alembic.ini             # Alembic configuration
‚îî‚îÄ‚îÄ backend/
    ‚îú‚îÄ‚îÄ models.py           # SQLAlchemy models
    ‚îî‚îÄ‚îÄ database.py         # Database connection

Key Configuration Files    

alembic.ini

[alembic]
script_location = alembic
sqlalchemy.url = sqlite:///./backend/banco.db

[post_write_hooks]
hooks = black
black.type = console_scripts
black.entrypoint = black

alembic/env.py

from backend.models import Base
from backend.database import engine

# Set target metadata for auto-generation
target_metadata = Base.metadata


# Configure connection
with engine.connect() as connection:
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

Common Commands
Generate New Migration

# Auto-generate migration from model changes
alembic revision --autogenerate -m "Add new orders table"

# Create empty migration (for custom SQL)
alembic revision -m "Add custom index"

Apply Migrations

# Apply all pending migrations
alembic upgrade head

# Apply specific migration
alembic upgrade ae1027a6acf

# Apply next migration only
alembic upgrade +1

# Migration History

# View migration history
alembic history --verbose

# Show current migration
alembic current

# Show pending migrations
alembic show head

Rollback Operations

# Rollback last migration
alembic downgrade -1

# Rollback to specific migration
alembic downgrade ae1027a6acf

# Rollback all migrations
alembic downgrade base

Migration Workflow
1. Modify Models

# backend/models.py
class Pedido(Base):
    __tablename__ = "pedidos"
    
    id = Column(Integer, primary_key=True)
    status = Column(String(20), default="ATIVO")
    # Add new column
    priority = Column(String(10), default="NORMAL")  # ‚Üê New field

2. Generate Migration

alembic revision --autogenerate -m "Add priority field to orders"

3. Review Generated Migration

# alembic/versions/xxx_add_priority_field.py
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('pedidos', sa.Column('priority', sa.String(10), nullable=True))
    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('pedidos', 'priority')
    # ### end Alembic commands ###

4. Test Migration

# Apply migration
alembic upgrade head

# Test your application
python -m pytest tests/

# If issues, rollback
alembic downgrade -1

5. Deploy to Production

# In production environment
alembic upgrade head

Best Practices
‚úÖ Do's
Always review auto-generated migrations before applying
Test migrations on a copy of production data
Use descriptive migration messages
Keep migrations in version control
Backup database before major migrations
Use transactions for complex migrations
‚ùå Don'ts
Never edit already applied migrations
Don't skip migration review process
Avoid direct database schema changes
Don't delete migration files
Never force migrations in production

Common Migration Scenarios
Adding New Table

# Model change
class UserProfile(Base):
    __tablename__ = "user_profiles"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"))
    bio = Column(Text)

    alembic revision --autogenerate -m "Add user profiles table"

Adding Column with Default

# Generated migration
def upgrade():
    op.add_column('pedidos', sa.Column('created_at', sa.DateTime(), nullable=True))
    # Set default for existing records
    op.execute("UPDATE pedidos SET created_at = datetime('now') WHERE created_at IS NULL")
    # Make column non-nullable
    op.alter_column('pedidos', 'created_at', nullable=False)

Data Migration

# Custom migration for data transformation
def upgrade():
    # Schema change
    op.add_column('pedidos', sa.Column('status_code', sa.Integer()))
    
    # Data migration
    connection = op.get_bind()
    connection.execute(
        "UPDATE pedidos SET status_code = 1 WHERE status = 'ATIVO'"
    )
    connection.execute(
        "UPDATE pedidos SET status_code = 2 WHERE status = 'FINALIZADO'"
    )
Troubleshooting
Migration Conflicts

# Multiple developers, conflicting migrations
alembic merge -m "Merge conflicting migrations" head1 head2

Reset Migration History

# Nuclear option - only for development
alembic stamp head

Manual Migration State

# Mark migration as applied without running
alembic stamp ae1027a6acf

Integration with Development
Pre-commit Hook

#!/bin/bash
# .git/hooks/pre-commit
echo "Checking for pending migrations..."
if [ -n "$(alembic history -r head:head)" ]; then
    echo "‚úÖ Migrations up to date"
else
    echo "‚ùå Pending migrations found - run 'alembic upgrade head'"
    exit 1
fi

Development Workflow

# Daily development routine
git pull origin main
alembic upgrade head  # Apply any new migrations
# ... make your changes ...
alembic revision --autogenerate -m "Your changes"
alembic upgrade head
git add alembic/versions/
git commit -m "Add migration for new feature"

Production Deployment
Deployment Script

#!/bin/bash
# deploy.sh
echo "üöÄ Deploying Order Management System..."

# Backup database
cp backend/banco.db backend/banco.db.backup.$(date +%Y%m%d_%H%M%S)

# Apply migrations
echo "üìä Running database migrations..."
alembic upgrade head

# Start application
echo "üéØ Starting FastAPI application..."
uvicorn backend.main:app --host 0.0.0.0 --port 8000

Monitoring

# Check migration status in health endpoint
@app.get("/health")
async def health_check():
    # Check if migrations are up to date
    current = alembic.command.current(alembic_cfg)
    head = alembic.command.heads(alembic_cfg)
    
    return {
        "status": "healthy",
        "database": {
            "current_migration": current,
            "latest_migration": head,
            "migrations_pending": current != head
        }
    }

Conclusion
Alembic is essential for professional database management in the Order Management System. It provides:

üîÑ Version control for database schemas
üöÄ Safe deployments with rollback capabilities
üë• Team collaboration through shared migration history
üè≠ Production reliability with tested migration workflows
By following these practices, your database evolves safely alongside your application code, maintaining data integrity and enabling confident deployments.

Resources
Alembic Documentation
SQLAlchemy ORM Tutorial
Database Migration Best Practices    


